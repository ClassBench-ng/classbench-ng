require 'tempfile'
require 'pp'
require 'open4'

module Classbench
	class Generator
		attr_accessor :openflow_section

		# Rules generated by classbench
		attr_accessor :classbench_rules

		# Full path to seed, needs to be stored for later generation
		attr_accessor :seed_path

		# Array of arrays containing footprint for OpenFlow rule,
		# as if they were from original set, but without values
		# Ex: [["tp_dst"], ["nw_src", "nw_dst"]
		attr_accessor :pregenerated_rule_types

		attr_accessor :pregenerated_dl_srcs
		attr_accessor :pregenerated_dl_dsts

		def initialize(filename)
			self.seed_path = filename
			self.classbench_rules = []
		end

		def parse_seed
			begin
				openflow_raw = File.read(self.seed_path).match(/openflow\n(.*)#/mi).captures.first
				self.openflow_section = YAML.load(openflow_raw)
				#pp self.openflow_section

				pregenerate_rule_types
				pregenerate_dl

				#p pregenerated_rule_types.count
			rescue NoMethodError
				STDERR.puts "No openflow section found in seed."
			end
		end

		##########################

		def pregenerate_rule_types
			self.pregenerated_rule_types = []

			self.openflow_section["rule_counts"].each do |rule_count|
				rule_count["count"].times do
					self.pregenerated_rule_types << rule_count["attributes"]
				end
			end
		end

		def pregenerate_dl
			self.pregenerated_dl_srcs = []
			self.openflow_section["dl_src"].each do |vendor, count|
				count.to_i.times do
					self.pregenerated_dl_srcs << vendor
				end
			end

			self.pregenerated_dl_dsts = []
			self.openflow_section["dl_dst"].each do |vendor, count|
				count.to_i.times do
					self.pregenerated_dl_dsts << vendor
				end
			end
		end

		##########################
		def generate_classbench_rules(count)
			current_dir = File.dirname(__FILE__)
			tmp_filters = Tempfile.new('filters')

			# db_generator -c filename #{count} 0 0 0 tmp/#{rand}
			# Call classbench
			#system(current_dir+"/db_generator", "-c", self.seed_path, count.to_s, "0", "0", "0", tmp_filters.path, " > /dev/null")
			pid, stdin, stdout, stderr = Open4::popen4(current_dir+"/db_generator", "-c", self.seed_path, count.to_s, "0", "0", "0", tmp_filters.path)
			ignored, status = Process::waitpid2 pid

			#puts status
			#puts $?

			raw_rules = File.readlines(tmp_filters.path)
			raw_rules.each do |classbench_line|
				self.classbench_rules << Rule.from_classbench_format(classbench_line)
			end
		end

		def generate_rules(count)
			generate_classbench_rules(count)
			all_generated_rules = []

			return classbench_rules.map do |rule|
				random_openflow_type = pregenerated_rule_types.sample
				rule.remove_missing_attributes(random_openflow_type)

				random_openflow_type.each do |attribute|
					p random_openflow_type
					if not rule.attributes.include?(attribute)
						#puts "Fill #{attribute}"

						random_device_mac = (1..3).collect { "%02x" % [rand(255)] }.join(":")
						if attribute == "dl_dst"
							random_vendor = pregenerated_dl_dsts.sample
							rule.attributes["dl_dst"] = random_vendor + ":" + random_device_mac
						end

						if attribute == "dl_src"
							random_vendor = pregenerated_dl_srcs.sample
							rule.attributes["dl_src"] = random_vendor + ":" + random_device_mac
						end

						if attribute == "dl_vlan"
							rule.attributes["dl_vlan"] = rand(4096)
						end
					end
				end

				rule
				#p random_openflow_type
				#puts
			end
		end
	end
end
